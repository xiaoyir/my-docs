import{_ as a,c as n,o as s,d as e}from"./app-DJofJ6VS.js";const i={},l=e(`<h1 id="spring正式弃用java-8-还不赶紧学java-21" tabindex="-1"><a class="header-anchor" href="#spring正式弃用java-8-还不赶紧学java-21"><span>Spring正式弃用Java 8，还不赶紧学Java 21!</span></a></h1><h2 id="java-8被弃用了" tabindex="-1"><a class="header-anchor" href="#java-8被弃用了"><span>Java 8被弃用了</span></a></h2><p>作为Java开发程序员，相信大家都对spring框架很熟悉，无论是搭建微服务还是开发web应用，都离不开spring全家桶。但是Spring官方最近整了个大活，他们弃用Java 8 了！</p><p>Spring Framework从6.0版本开始，IntelliJ IDEA从2023.3版本开始，Spring Boot从3.0版本开始，这三个都不再支持JDK 1.8，而是需要JDK 17或更高版本。这对于能用就用，不能用再换，喜欢使用Java 8 的大多数程序员来说，简直是晴天霹雳，这就好比你本来已经习惯了用筷子夹肉，突然筷子换成了刀叉，工具不一样总是会让人膈应。</p><p>从Spring boot的脚手架官网中，地址https://start.spring.io/可以看出，spring initializr中确实没有了Java 8，真是时代抛弃你，招呼都不打一声。</p><figure><img src="https://javacool.oss-cn-shenzhen.aliyuncs.com/img/xyr/20240525165018.png" alt="spring-init" tabindex="0" loading="lazy"><figcaption>spring-init</figcaption></figure><h2 id="要不要换-该不该换" tabindex="-1"><a class="header-anchor" href="#要不要换-该不该换"><span>要不要换，该不该换</span></a></h2><p>不过大家也不用慌，可以改用阿里云的脚手架https://start.aliyun.com/，或者自己从0到1搭建适配java8版本的springboot项目都是可以的，相信这些也都难不倒各位大佬们。</p><p>但是java如今都已经迭代到21版本了，也引入了很多新的特性，做了不少提升性能的改进，为什么国外都推荐使用java17或java21，但是国内还是喜欢用java8呢？</p><p>首先一个就是历史原因，维护老项目，Java 8确实是一个非常稳定和成熟的版本，拥有很好的生态和兼容性，可以满足大多数公司的使用需求，就连小义现在负责的项目，也是使用的java 8 。其次就是成本和风险，Java 8之后的版本都有一些破坏性的变化，比如模块化、弃用和移除一些API等，升级有安全隐患。这些或许是国内很多公司没有选择升级JDK的原因吧。</p><p>然而Spring官方代表的就是权威，总不能一直苟着用java8吧。很重要的一点是，Java 8的支持时间已经接近尾声，将于2030年结束，而Java 17和Java 21都是长期支持（LTS）版本，可以得到更长时间的维护和更新，而不是每半年就换一个版本。另外Java 17和Java 21都与云原生和微服务的发展趋势相适应，可以让Java应用更容易地部署和管理在云端，也可以利用模块化和AOT等技术，减少Java应用的体积和启动时间。现实就是这么残酷。</p><p>在15、16年的时候，java8还是很新的，那时候也很多人说要坚守java7，结果呢，还不是被淘汰了。前几年，新兴的go语言因为具备java8所没有的一些特性，比如更轻量级的线程——协程，而大受青睐，不少大佬还不惜一切代价从底层翻新，把项目从java换成了go。也正因编程语言之间的相互竞争，java才能不断迭代更新自我完善，在21版本也引入了虚拟线程来支持类似于go协程的这一高性能实现方式。</p><h2 id="java-21新特性" tabindex="-1"><a class="header-anchor" href="#java-21新特性"><span>Java 21新特性</span></a></h2><p>所以技术还是要学的，不能固步自封，还是先来熟悉一下java21在代码方面都新增了哪些特性吧。</p><h3 id="_1、序列集合" tabindex="-1"><a class="header-anchor" href="#_1、序列集合"><span>1、序列集合</span></a></h3><p>是一种表示按照预定义的顺序排列的元素的集合的接口，可以提供更统一和高效的操作。例如，创建一个有序的集合可以使用SequencedSet接口，并使用first()和last()方法来获取第一个和最后一个元素，或者使用reverseIterator()方法来逆序遍历集合。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>// 创建一个有序的集合  </span></span>
<span class="line"><span>SequencedSet&lt;String&gt; names = new LinkedHashSet&lt;&gt;();  </span></span>
<span class="line"><span>names.add(&quot;Alice&quot;);  </span></span>
<span class="line"><span>names.add(&quot;Bob&quot;);  </span></span>
<span class="line"><span>names.add(&quot;Charlie&quot;);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 获取第一个和最后一个元素  </span></span>
<span class="line"><span>System.out.println(names.first()); // Alice  </span></span>
<span class="line"><span>System.out.println(names.last()); // Charlie</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 逆序遍历集合  </span></span>
<span class="line"><span>for (String name : names.reverseIterator()) {  </span></span>
<span class="line"><span>System.out.println(name);  </span></span>
<span class="line"><span>}  </span></span>
<span class="line"><span>// Charlie  </span></span>
<span class="line"><span>// Bob  </span></span>
<span class="line"><span>// Alice</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2、分代zgc" tabindex="-1"><a class="header-anchor" href="#_2、分代zgc"><span>2、分代ZGC</span></a></h3><p>是一种将Z垃圾回收器扩展为维护年轻对象和年老对象的独立生成的功能，可以提高应用程序性能和内存利用率。要启用分代 ZGC，可以使用-XX:+UseZGC -XX:+ZGenerational选项。</p><h3 id="_3、记录模式" tabindex="-1"><a class="header-anchor" href="#_3、记录模式"><span>3、记录模式</span></a></h3><p>是一种用于解构记录值的模式匹配功能，可以嵌套记录模式和类型模式，实现数据导航和处理。例如，可以使用记录模式来匹配一个记录类型的对象，并提取其中的组件值。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>// 定义一个记录类型  </span></span>
<span class="line"><span>record Point(int x, int y) {}  </span></span>
<span class="line"><span>// 创建一个记录对象  </span></span>
<span class="line"><span>Point p = new Point(10, 20);  </span></span>
<span class="line"><span>// 使用记录模式匹配记录对象，并提取组件值  </span></span>
<span class="line"><span>if (p instanceof Point(int x, int y)) {  </span></span>
<span class="line"><span>System.out.println(x + y); // 30  </span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4、switch-模式匹配" tabindex="-1"><a class="header-anchor" href="#_4、switch-模式匹配"><span>4、switch 模式匹配</span></a></h3><p>是一种用于switch表达式和语句的模式匹配功能，可以针对多个模式测试表达式，每个模式都有一个特定的操作，实现复杂的面向数据的查询。例如，可以使用switch模式匹配来根据不同的类型和值进行格式化。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>// 定义一个格式化的方法，使用switch模式匹配</span></span>
<span class="line"><span>static String formatterPatternSwitch(Object obj) {</span></span>
<span class="line"><span>    return switch (obj) {</span></span>
<span class="line"><span>        case Integer i -&gt; String.format(&quot;int %d&quot;, i);</span></span>
<span class="line"><span>        case Long l -&gt; String.format(&quot;long %d&quot;, l);</span></span>
<span class="line"><span>        case Double d -&gt; String.format(&quot;double %f&quot;, d);</span></span>
<span class="line"><span>        case String s -&gt; String.format(&quot;String %s&quot;, s);</span></span>
<span class="line"><span>        default -&gt; obj.toString();</span></span>
<span class="line"><span>    };</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>// 调用格式化的方法</span></span>
<span class="line"><span>System.out.println(formatterPatternSwitch(10)); // int 10</span></span>
<span class="line"><span>System.out.println(formatterPatternSwitch(10L)); // long 10</span></span>
<span class="line"><span>System.out.println(formatterPatternSwitch(10.0)); // double 10.000000</span></span>
<span class="line"><span>System.out.println(formatterPatternSwitch(&quot;Hello&quot;)); // String Hello</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_5、虚拟线程" tabindex="-1"><a class="header-anchor" href="#_5、虚拟线程"><span>5、虚拟线程</span></a></h3><p>本次升级重中之重，是一种轻量级线程的功能，可以显著减少编写、维护和观察高吞吐量并发应用程序的工作量。虚拟线程可以使用Thread.ofVirtual()方法来创建，并使用start()方法来启动，与普通线程的用法类似，但是虚拟线程不需要使用线程池来复用，也不需要使用同步机制来避免竞争，而是可以自动调度和管理。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>// 创建一个虚拟线程  </span></span>
<span class="line"><span>Thread vt = Thread.ofVirtual().start(() -&gt; {  </span></span>
<span class="line"><span>System.out.println(&quot;Hello from virtual thread&quot;);  </span></span>
<span class="line"><span>});  </span></span>
<span class="line"><span>// 等待虚拟线程结束  </span></span>
<span class="line"><span>vt.join();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_6、密钥封装机制api" tabindex="-1"><a class="header-anchor" href="#_6、密钥封装机制api"><span>6、密钥封装机制API</span></a></h3><p>是一种用于密钥封装机制的API，这是一种使用公钥加密来保护对称密钥的加密技术。例如，可以使用KeyAgreement类来实现密钥封装机制，如下所示：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>// 生成公钥和私钥</span></span>
<span class="line"><span>KeyPairGenerator kpg = KeyPairGenerator.getInstance(&quot;EC&quot;);</span></span>
<span class="line"><span>kpg.initialize(256);</span></span>
<span class="line"><span>KeyPair kp = kpg.generateKeyPair();</span></span>
<span class="line"><span>PublicKey pub = kp.getPublic();</span></span>
<span class="line"><span>PrivateKey priv = kp.getPrivate();</span></span>
<span class="line"><span>// 生成对称密钥</span></span>
<span class="line"><span>KeyGenerator kg = KeyGenerator.getInstance(&quot;AES&quot;);</span></span>
<span class="line"><span>kg.init(256);</span></span>
<span class="line"><span>SecretKey sk = kg.generateKey();</span></span>
<span class="line"><span>// 使用公钥加密对称密钥</span></span>
<span class="line"><span>KeyAgreement ka = KeyAgreement.getInstance(&quot;ECDH&quot;);</span></span>
<span class="line"><span>ka.init(priv);</span></span>
<span class="line"><span>ka.doPhase(pub, true);</span></span>
<span class="line"><span>byte[] wrapped = ka.wrap(sk);</span></span>
<span class="line"><span>// 使用私钥解密对称密钥</span></span>
<span class="line"><span>ka.init(priv);</span></span>
<span class="line"><span>ka.doPhase(pub, true);</span></span>
<span class="line"><span>SecretKey unwrapped = (SecretKey) ka.unwrap(wrapped, &quot;AES&quot;, Cipher.SECRET_KEY);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,31),p=[l];function t(r,c){return s(),n("div",null,p)}const v=a(i,[["render",t],["__file","Java21新特性.html.vue"]]),o=JSON.parse('{"path":"/skill/java/Java21%E6%96%B0%E7%89%B9%E6%80%A7.html","title":"Java21新特性","lang":"zh-CN","frontmatter":{"title":"Java21新特性","icon":"laptop-code","category":["java"],"description":"Spring正式弃用Java 8，还不赶紧学Java 21! Java 8被弃用了 作为Java开发程序员，相信大家都对spring框架很熟悉，无论是搭建微服务还是开发web应用，都离不开spring全家桶。但是Spring官方最近整了个大活，他们弃用Java 8 了！ Spring Framework从6.0版本开始，IntelliJ IDEA从20...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/my-docs/skill/java/Java21%E6%96%B0%E7%89%B9%E6%80%A7.html"}],["meta",{"property":"og:site_name","content":"Java库"}],["meta",{"property":"og:title","content":"Java21新特性"}],["meta",{"property":"og:description","content":"Spring正式弃用Java 8，还不赶紧学Java 21! Java 8被弃用了 作为Java开发程序员，相信大家都对spring框架很熟悉，无论是搭建微服务还是开发web应用，都离不开spring全家桶。但是Spring官方最近整了个大活，他们弃用Java 8 了！ Spring Framework从6.0版本开始，IntelliJ IDEA从20..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://javacool.oss-cn-shenzhen.aliyuncs.com/img/xyr/20240525165018.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-06-02T12:57:40.000Z"}],["meta",{"property":"article:author","content":"程序员小义"}],["meta",{"property":"article:modified_time","content":"2024-06-02T12:57:40.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java21新特性\\",\\"image\\":[\\"https://javacool.oss-cn-shenzhen.aliyuncs.com/img/xyr/20240525165018.png\\"],\\"dateModified\\":\\"2024-06-02T12:57:40.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"程序员小义\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"Java 8被弃用了","slug":"java-8被弃用了","link":"#java-8被弃用了","children":[]},{"level":2,"title":"要不要换，该不该换","slug":"要不要换-该不该换","link":"#要不要换-该不该换","children":[]},{"level":2,"title":"Java 21新特性","slug":"java-21新特性","link":"#java-21新特性","children":[{"level":3,"title":"1、序列集合","slug":"_1、序列集合","link":"#_1、序列集合","children":[]},{"level":3,"title":"2、分代ZGC","slug":"_2、分代zgc","link":"#_2、分代zgc","children":[]},{"level":3,"title":"3、记录模式","slug":"_3、记录模式","link":"#_3、记录模式","children":[]},{"level":3,"title":"4、switch 模式匹配","slug":"_4、switch-模式匹配","link":"#_4、switch-模式匹配","children":[]},{"level":3,"title":"5、虚拟线程","slug":"_5、虚拟线程","link":"#_5、虚拟线程","children":[]},{"level":3,"title":"6、密钥封装机制API","slug":"_6、密钥封装机制api","link":"#_6、密钥封装机制api","children":[]}]}],"git":{"createdTime":1717320269000,"updatedTime":1717333060000,"contributors":[{"name":"whuhbz","email":"463436681@qq.com","commits":1}]},"readingTime":{"minutes":5.79,"words":1736},"filePathRelative":"skill/java/Java21新特性.md","localizedDate":"2024年6月2日","excerpt":"\\n<h2>Java 8被弃用了</h2>\\n<p>作为Java开发程序员，相信大家都对spring框架很熟悉，无论是搭建微服务还是开发web应用，都离不开spring全家桶。但是Spring官方最近整了个大活，他们弃用Java 8 了！</p>\\n<p>Spring Framework从6.0版本开始，IntelliJ IDEA从2023.3版本开始，Spring Boot从3.0版本开始，这三个都不再支持JDK 1.8，而是需要JDK 17或更高版本。这对于能用就用，不能用再换，喜欢使用Java 8 的大多数程序员来说，简直是晴天霹雳，这就好比你本来已经习惯了用筷子夹肉，突然筷子换成了刀叉，工具不一样总是会让人膈应。</p>","autoDesc":true}');export{v as comp,o as data};
