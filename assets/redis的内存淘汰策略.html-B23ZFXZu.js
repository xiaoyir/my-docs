import{_ as e,c as i,o as s,d as l}from"./app-BeG2TDbG.js";const a={},t=l(`<h1 id="redis的key过期如何删除-有哪些内存淘汰策略" tabindex="-1"><a class="header-anchor" href="#redis的key过期如何删除-有哪些内存淘汰策略"><span>Redis的key过期如何删除？有哪些内存淘汰策略？</span></a></h1><p>随着业务的发展，数据量激增，Redis作为缓存数据库，其内存使用量不可避免地会增长。但内存终究是有限的，一台服务器的内存也就8G或者16G，redis也不可能全部占用，因为一部分内存也需要用来维持系统运行。那redis又该怎么处理内存占用过多的情况呢？</p><h3 id="key设置过期时间" tabindex="-1"><a class="header-anchor" href="#key设置过期时间"><span>key设置过期时间</span></a></h3><p>在设计缓存策略时，给键设置过期时间是一种常见的做法。这不仅有助于释放不再需要的数据占用的内存空间，还可以防止内存泄漏，保证系统的稳定性和响应速度。</p><p>Redis设置的生存时间（TTL，time-to-live）是针对key的。当key的生存时间到达预定值时，这个key将被视为过期。但是，过期并不意味着它会立即从数据库中被删除。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span># 常用的四种设置key过期时间的命令</span></span>
<span class="line"><span></span></span>
<span class="line"><span>EXPIRE &lt;key&gt; &lt;ttl&gt; #表示将键 key 的生存时间设置为 ttl 秒。</span></span>
<span class="line"><span> </span></span>
<span class="line"><span>PEXPIRE &lt;key&gt; &lt;ttl&gt; #表示将键 key 的生存时间设置为 ttl 毫秒。</span></span>
<span class="line"><span> </span></span>
<span class="line"><span>EXPIREAT &lt;key&gt; &lt;timestamp&gt; #表示将键 key 的生存时间设置为 timestamp 所指定的秒数时间戳。</span></span>
<span class="line"><span> </span></span>
<span class="line"><span>PEXPIREAT &lt;key&gt; &lt;timestamp&gt; #表示将键 key 的生存时间设置为 timestamp 所指定的毫秒数时间戳。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Redis主要通过两种策略来删除过期的key，即“惰性删除”与“定期删除”。这两种策略相辅相成，旨在平衡内存使用和性能开销。</p><ul><li><p>惰性删除：当客户端请求一个key时，Redis会检查该key是否已过期。如果已经过期，Redis就在这个时间点删除该key，然后返回一个错误。这个策略的优点是简单且资源开销小，但缺点是如果过期的key很长时间不被访问，它们将占用内存。</p></li><li><p>定期删除：为了解决惰性删除的缺点，Redis会定期随机测试一批key，检查并删除其中过期的key。这个策略可以更积极地释放内存，但是，频繁地进行定期删除操作可能会对系统性能产生影响。</p></li></ul><h3 id="内存淘汰策略" tabindex="-1"><a class="header-anchor" href="#内存淘汰策略"><span>内存淘汰策略</span></a></h3><p>虽然说给key设置过期时间可以节省一部分内存空间，但是当数据量大时，内存使用量很快就会达到配置的上限，新写入的数据将无法存储，这就需要我们预先设定内存淘汰策略，以决定哪些数据应该被淘汰，从而为新数据腾出空间。</p><p>Redis提供了多种内存淘汰策略，每种策略都有其特定的使用场景和规则。以下是一些常用的内存淘汰策略：</p><ul><li><p>noevition（默认）：此策略不会对缓存的数据进行淘汰，当内存不够了就会返回报错，因此如果真实数据集大于缓存容量，请改用其他策略。</p></li><li><p>volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰。</p></li><li><p>allkeys-lru：从所有数据集中挑选最近最少使用的数据淘汰。</p></li><li><p>volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰。</p></li><li><p>volatile-random：从已设置过期时间的数据集中随机挑选数据淘汰。</p></li><li><p>allkeys-random：从所有数据集中随机挑选数据淘汰。</p></li><li><p>volatile-lfu：从已设置过期时间的数据集中挑选使用频率最低的数据淘汰。</p></li></ul><p>从开发的角度出发，选择合适的内存淘汰策略需要考虑业务特点和数据特性。例如，对于一个主要存储用户会话的系统，可能会选择volatile-lru策略，因为会话通常具有时效性，且最近不活跃的会话可以被优先淘汰。</p><p>而对于需要保证数据尽可能被缓存的场景，如热点数据缓存，可能会考虑使用allkeys-lru策略，以确保最近最少使用的数据被替换，从而提高缓存命中率。</p><p>可通过下面的命令修改淘汰策略。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>config set maxmemory-policy allkeys-lru</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="淘汰策略触发机制" tabindex="-1"><a class="header-anchor" href="#淘汰策略触发机制"><span>淘汰策略触发机制</span></a></h3><p>Redis的内存淘汰策略通常会在以下两种情况下触发执行：</p><ul><li><p>写命令时：当Redis尝试写入数据时，如果检测到内存使用已经达到了配置的maxmemory限制，Redis就会根据当前设置的内存淘汰策略（例如volatile-lru, allkeys-lru, volatile-random, allkeys-random, volatile-ttl, noeviction等）进行内存清理。在写入新数据前，它会淘汰一些旧数据来释放内存空间，除非配置的是noeviction策略，那么它会拒绝写入并返回错误。</p></li><li><p>定期删除任务：Redis的后台任务会周期性地检查内存使用情况，并根据配置的淘汰策略清除过期或不常用的数据。这是按照一定的时间间隔进行的，以防止内存使用长时间超出限制。这种定期任务结合了惰性删除和主动清理策略，以优化内存使用效率。</p></li></ul><h2 id="结语" tabindex="-1"><a class="header-anchor" href="#结语"><span>结语</span></a></h2><p>Redis作为一个强大的工具，在处理过期key时提供了灵活且高效的策略。深入理解这些机制，并通过合理的策略使用，可以确保应用程序在高效使用内存的同时，也能保持良好的响应速度。</p>`,21),n=[t];function p(d,r){return s(),i("div",null,n)}const c=e(a,[["render",p],["__file","redis的内存淘汰策略.html.vue"]]),h=JSON.parse('{"path":"/skill/redis/redis%E7%9A%84%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5.html","title":"Redis的key过期如何删除？有哪些内存淘汰策略？","lang":"zh-CN","frontmatter":{"description":"Redis的key过期如何删除？有哪些内存淘汰策略？ 随着业务的发展，数据量激增，Redis作为缓存数据库，其内存使用量不可避免地会增长。但内存终究是有限的，一台服务器的内存也就8G或者16G，redis也不可能全部占用，因为一部分内存也需要用来维持系统运行。那redis又该怎么处理内存占用过多的情况呢？ key设置过期时间 在设计缓存策略时，给键设置...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/my-docs/skill/redis/redis%E7%9A%84%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5.html"}],["meta",{"property":"og:site_name","content":"Java库"}],["meta",{"property":"og:title","content":"Redis的key过期如何删除？有哪些内存淘汰策略？"}],["meta",{"property":"og:description","content":"Redis的key过期如何删除？有哪些内存淘汰策略？ 随着业务的发展，数据量激增，Redis作为缓存数据库，其内存使用量不可避免地会增长。但内存终究是有限的，一台服务器的内存也就8G或者16G，redis也不可能全部占用，因为一部分内存也需要用来维持系统运行。那redis又该怎么处理内存占用过多的情况呢？ key设置过期时间 在设计缓存策略时，给键设置..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-06-02T09:24:29.000Z"}],["meta",{"property":"article:author","content":"程序员小义"}],["meta",{"property":"article:modified_time","content":"2024-06-02T09:24:29.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis的key过期如何删除？有哪些内存淘汰策略？\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-06-02T09:24:29.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"程序员小义\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":3,"title":"key设置过期时间","slug":"key设置过期时间","link":"#key设置过期时间","children":[]},{"level":3,"title":"内存淘汰策略","slug":"内存淘汰策略","link":"#内存淘汰策略","children":[]},{"level":3,"title":"淘汰策略触发机制","slug":"淘汰策略触发机制","link":"#淘汰策略触发机制","children":[]},{"level":2,"title":"结语","slug":"结语","link":"#结语","children":[]}],"git":{"createdTime":1717320269000,"updatedTime":1717320269000,"contributors":[{"name":"whuhbz","email":"463436681@qq.com","commits":1}]},"readingTime":{"minutes":4.69,"words":1406},"filePathRelative":"skill/redis/redis的内存淘汰策略.md","localizedDate":"2024年6月2日","excerpt":"\\n<p>随着业务的发展，数据量激增，Redis作为缓存数据库，其内存使用量不可避免地会增长。但内存终究是有限的，一台服务器的内存也就8G或者16G，redis也不可能全部占用，因为一部分内存也需要用来维持系统运行。那redis又该怎么处理内存占用过多的情况呢？</p>\\n<h3>key设置过期时间</h3>\\n<p>在设计缓存策略时，给键设置过期时间是一种常见的做法。这不仅有助于释放不再需要的数据占用的内存空间，还可以防止内存泄漏，保证系统的稳定性和响应速度。</p>\\n<p>Redis设置的生存时间（TTL，time-to-live）是针对key的。当key的生存时间到达预定值时，这个key将被视为过期。但是，过期并不意味着它会立即从数据库中被删除。</p>","autoDesc":true}');export{c as comp,h as data};
