import{_ as n,c as s,o as e,d as a}from"./app-9aLaKr4C.js";const i={},l=a(`<h1 id="sentinel实操-微服务稳定性的流量守护神" tabindex="-1"><a class="header-anchor" href="#sentinel实操-微服务稳定性的流量守护神"><span>Sentinel实操：微服务稳定性的流量守护神</span></a></h1><p>应运时代而生的Sentinel，旨在为分布式系统提供流量控制和熔断降级等功能，维护服务之间的稳定性。从12年由阿里巴巴中间件团队推出至今，已经成为主流的限流中间件，也承接了阿里巴巴近10年的双十一大促流量的核心场景，例如秒杀、消息削峰填谷、集群流量控制等。</p><p>项目地址：https://github.com/alibaba/Sentinel， 总体架构图如下:</p><p><img src="https://javacool.oss-cn-shenzhen.aliyuncs.com/img/xyr/20240525172753.png" alt="img" loading="lazy"> 下来一起来简单实操体验一下</p><h2 id="_1、docker部署" tabindex="-1"><a class="header-anchor" href="#_1、docker部署"><span>1、docker部署</span></a></h2><p>推荐使用docker部署sentinel</p><ol><li><p>安装docker</p><p>apt install docker.io</p></li><li><p>启动docker守护进程</p><p>systemctl start docker</p></li><li><p>拉取镜像</p><p>docker pull bladex/sentinel-dashboard:1.7.0</p></li><li><p>容器运行</p><p>docker run --name sentinel -d -p 8858:8858 bladex/sentinel-dashboard:1.7.0</p></li></ol><p>--name取别名，docker run -d后台运行，-p定义端口</p><ol start="5"><li><p>查看运行状态</p><p>docker ps -a</p></li><li><p>访问登录页面</p></li></ol><p>http://localhost:8858，账号/密码：sentinel/sentinel</p><figure><img src="https://javacool.oss-cn-shenzhen.aliyuncs.com/img/xyr/20240525172818.png" alt="img_2" tabindex="0" loading="lazy"><figcaption>img_2</figcaption></figure><h2 id="_2、spring整合" tabindex="-1"><a class="header-anchor" href="#_2、spring整合"><span>2、Spring整合</span></a></h2><ol><li>maven依赖</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>&lt;dependency&gt;  </span></span>
<span class="line"><span>    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;  </span></span>
<span class="line"><span>    &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;  </span></span>
<span class="line"><span>    &lt;version&gt;\${sentinel.version}&lt;/version&gt;  </span></span>
<span class="line"><span>&lt;/dependency&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>配置项参数</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>spring.cloud.sentinel.transport.dashboard=localhost:8858  </span></span>
<span class="line"><span>spring.cloud.sentinel.transport.heartbeat-interval-ms=500  </span></span>
<span class="line"><span>spring.cloud.sentinel.eager=true</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意，sentinel默认采用延迟加载，只有在主动发起一次请求后，才会被拦截并发送给服务端。如果想关闭这个延迟，可以把eager的注释放掉。</p><h2 id="_3、客户端测试" tabindex="-1"><a class="header-anchor" href="#_3、客户端测试"><span>3、客户端测试</span></a></h2><h3 id="_3-1-接口限流" tabindex="-1"><a class="header-anchor" href="#_3-1-接口限流"><span>3.1 接口限流</span></a></h3><p>按如上步骤新建springBoot项目，整合sentinel，设置项目名参数，方便在sentinel控制台查找该应用：spring.application.name=mySentinel</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>//测试类代码：</span></span>
<span class="line"><span>@RestController</span></span>
<span class="line"><span>@RequestMapping(&quot;/test&quot;)</span></span>
<span class="line"><span>public class TestController {</span></span>
<span class="line"><span>    @GetMapping(value = &quot;/fall&quot;)</span></span>
<span class="line"><span>    @SentinelResource(value = &quot;fall&quot;)</span></span>
<span class="line"><span>    public String fall() {</span></span>
<span class="line"><span>        return &quot;Hello Sentinel&quot;;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>启动项目成功后在sentinel控制台显示如下，新建流控规则，单机阙值设置大于0，如1则表示1s内只能访问一次。</p><p><img src="https://javacool.oss-cn-shenzhen.aliyuncs.com/img/xyr/20240525172830.png" alt="img_1" loading="lazy"> 资源名和@SentinelResource注解定义的一样，都为&quot;fall&quot;时，触发限流页面返回：Whitelabel Error Page</p><p>资源名和接口访问的url一样，都为&quot;/test/fall&quot;时，触发限流页面返回：Blocked by Sentinel (flow limiting)</p><h3 id="_3-2-定义回调" tabindex="-1"><a class="header-anchor" href="#_3-2-定义回调"><span>3.2 定义回调</span></a></h3><p>运用到@SentinelResource的两大属性。blockHandler：针对违反Sentinel控制台配置规则时触发BlockException异常时的处理 fallback：针对Java本身出现的异常进行处理。</p><h3 id="_3-2-1-fallback" tabindex="-1"><a class="header-anchor" href="#_3-2-1-fallback"><span>3.2.1 fallback</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>//测试代码：</span></span>
<span class="line"><span>@RestController</span></span>
<span class="line"><span>@RequestMapping(&quot;/test&quot;)</span></span>
<span class="line"><span>public class TestController {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * fallback：针对Java本身出现的异常进行处理的对应属性,触发时会执行对应的方法（如该示例中的getHandlerFallback）</span></span>
<span class="line"><span>     * @return</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    @GetMapping(value = &quot;/fall&quot;)</span></span>
<span class="line"><span>    @SentinelResource(value = &quot;fall&quot;, fallback = &quot;getHandlerFallback&quot;)</span></span>
<span class="line"><span>    public String fall(Long id) {</span></span>
<span class="line"><span>        if(id == 1){</span></span>
<span class="line"><span>            throw new RuntimeException(&quot;程序报错&quot;);</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        return &quot;Hello Sentinel&quot;;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    public static String getHandlerFallBack(BlockException blockException){</span></span>
<span class="line"><span>        return &quot;执行异常,请检查程序后重试...&quot;;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-2-2-blockhandler" tabindex="-1"><a class="header-anchor" href="#_3-2-2-blockhandler"><span>3.2.2 blockHandler</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>//测试代码：</span></span>
<span class="line"><span>/**</span></span>
<span class="line"><span> * blockHandler：针对违反Sentinel控制台配置规则时触发BlockException异常时对应处理的属性,其值“handle”为对应class中的方法</span></span>
<span class="line"><span> * @return</span></span>
<span class="line"><span> */</span></span>
<span class="line"><span>@GetMapping(value = &quot;/hand&quot;)</span></span>
<span class="line"><span>@SentinelResource(value = &quot;hand&quot;, blockHandler = &quot;handle&quot;, blockHandlerClass = SentinelExceptionHandler.class)</span></span>
<span class="line"><span>public String hand() {</span></span>
<span class="line"><span>    return &quot;Hello Sentinel&quot;;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>/**</span></span>
<span class="line"><span> * BlockException包含很多个子类，分别对应不同的场景：</span></span>
<span class="line"><span> * 异常                       说明</span></span>
<span class="line"><span> * FlowException             限流异常</span></span>
<span class="line"><span> * ParamFlowException        热点参数限流的异常</span></span>
<span class="line"><span> * DegradeException          降级异常</span></span>
<span class="line"><span> * AuthorityException        授权规则异常</span></span>
<span class="line"><span> * SystemBlockException      系统规则异常</span></span>
<span class="line"><span> */</span></span>
<span class="line"><span>@Component</span></span>
<span class="line"><span>public class SentinelExceptionHandler implements BlockExceptionHandler {</span></span>
<span class="line"><span>    @Override</span></span>
<span class="line"><span>    public void handle(HttpServletRequest httpServletRequest, HttpServletResponse response, BlockException e) throws Exception {</span></span>
<span class="line"><span>        response.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());</span></span>
<span class="line"><span>        response.setContentType(&quot;application/json;charset=utf-8&quot;);</span></span>
<span class="line"><span>        response.getWriter().print(&quot;sentinel 限流...&quot;);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>大致的使用就是这样了，不过以上例子都是在 Web Servlet 环境下使用的。Sentinel 目前已经支持 Spring WebFlux，需要配合 spring-boot-starter-webflux 依赖触发 sentinel-starter 中 WebFlux 相关的自动化配置。当 Spring WebFlux 应用接入 Sentinel starter 后，所有的 URL 就自动成为 Sentinel 中的埋点资源，不用再额外添加资源注解，可以针对某个 URL 进行流控。</p><h2 id="_4、其他替代框架" tabindex="-1"><a class="header-anchor" href="#_4、其他替代框架"><span>4、其他替代框架</span></a></h2><p>那除了sentinel，还有哪些限流组件呢？下面这些发给大家参考：</p><ul><li><p>Hystrix：由Netflix开发，是最早的服务保护和断路器模式实现之一。尽管Netflix宣布不再积极开发Hystrix，但它仍然被广泛使用，并且有一个活跃的社区维护着该项目。</p></li><li><p>Resilience4j：这是一个轻量级的容错库，专为Java 8和函数式编程设计。它提供了断路器、限流器和重试机制等功能，是Spring Cloud之外的另一个选择。</p></li><li><p>Spring Cloud Circuit Breaker：这是Spring Cloud提供的一个抽象层，它整合了多种断路器实现，包括Hystrix、Resilience4j和Sentinel。</p></li><li><p>Istio：如果你的应用部署在Kubernetes上，Istio提供了一种服务网格解决方案，其中包括了流量管理、安全通信、监控等功能，也可以用于实现服务间的流量控制和熔断降级。</p></li></ul>`,34),p=[l];function t(c,r){return e(),s("div",null,p)}const o=n(i,[["render",t],["__file","Sentinel实操限流.html.vue"]]),u=JSON.parse('{"path":"/skill/sentinel/Sentinel%E5%AE%9E%E6%93%8D%E9%99%90%E6%B5%81.html","title":"Sentinel实操：微服务稳定性的流量守护神","lang":"zh-CN","frontmatter":{"description":"Sentinel实操：微服务稳定性的流量守护神 应运时代而生的Sentinel，旨在为分布式系统提供流量控制和熔断降级等功能，维护服务之间的稳定性。从12年由阿里巴巴中间件团队推出至今，已经成为主流的限流中间件，也承接了阿里巴巴近10年的双十一大促流量的核心场景，例如秒杀、消息削峰填谷、集群流量控制等。 项目地址：https://github.com/...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/my-docs/skill/sentinel/Sentinel%E5%AE%9E%E6%93%8D%E9%99%90%E6%B5%81.html"}],["meta",{"property":"og:site_name","content":"Java库"}],["meta",{"property":"og:title","content":"Sentinel实操：微服务稳定性的流量守护神"}],["meta",{"property":"og:description","content":"Sentinel实操：微服务稳定性的流量守护神 应运时代而生的Sentinel，旨在为分布式系统提供流量控制和熔断降级等功能，维护服务之间的稳定性。从12年由阿里巴巴中间件团队推出至今，已经成为主流的限流中间件，也承接了阿里巴巴近10年的双十一大促流量的核心场景，例如秒杀、消息削峰填谷、集群流量控制等。 项目地址：https://github.com/..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://javacool.oss-cn-shenzhen.aliyuncs.com/img/xyr/20240525172753.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-06-02T09:24:29.000Z"}],["meta",{"property":"article:author","content":"程序员小义"}],["meta",{"property":"article:modified_time","content":"2024-06-02T09:24:29.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Sentinel实操：微服务稳定性的流量守护神\\",\\"image\\":[\\"https://javacool.oss-cn-shenzhen.aliyuncs.com/img/xyr/20240525172753.png\\",\\"https://javacool.oss-cn-shenzhen.aliyuncs.com/img/xyr/20240525172818.png\\",\\"https://javacool.oss-cn-shenzhen.aliyuncs.com/img/xyr/20240525172830.png\\"],\\"dateModified\\":\\"2024-06-02T09:24:29.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"程序员小义\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"1、docker部署","slug":"_1、docker部署","link":"#_1、docker部署","children":[]},{"level":2,"title":"2、Spring整合","slug":"_2、spring整合","link":"#_2、spring整合","children":[]},{"level":2,"title":"3、客户端测试","slug":"_3、客户端测试","link":"#_3、客户端测试","children":[{"level":3,"title":"3.1 接口限流","slug":"_3-1-接口限流","link":"#_3-1-接口限流","children":[]},{"level":3,"title":"3.2 定义回调","slug":"_3-2-定义回调","link":"#_3-2-定义回调","children":[]},{"level":3,"title":"3.2.1 fallback","slug":"_3-2-1-fallback","link":"#_3-2-1-fallback","children":[]},{"level":3,"title":"3.2.2 blockHandler","slug":"_3-2-2-blockhandler","link":"#_3-2-2-blockhandler","children":[]}]},{"level":2,"title":"4、其他替代框架","slug":"_4、其他替代框架","link":"#_4、其他替代框架","children":[]}],"git":{"createdTime":1717320269000,"updatedTime":1717320269000,"contributors":[{"name":"whuhbz","email":"463436681@qq.com","commits":1}]},"readingTime":{"minutes":3.92,"words":1176},"filePathRelative":"skill/sentinel/Sentinel实操限流.md","localizedDate":"2024年6月2日","excerpt":"\\n<p>应运时代而生的Sentinel，旨在为分布式系统提供流量控制和熔断降级等功能，维护服务之间的稳定性。从12年由阿里巴巴中间件团队推出至今，已经成为主流的限流中间件，也承接了阿里巴巴近10年的双十一大促流量的核心场景，例如秒杀、消息削峰填谷、集群流量控制等。</p>\\n<p>项目地址：https://github.com/alibaba/Sentinel，\\n总体架构图如下:</p>\\n<p><img src=\\"https://javacool.oss-cn-shenzhen.aliyuncs.com/img/xyr/20240525172753.png\\" alt=\\"img\\" loading=\\"lazy\\">\\n下来一起来简单实操体验一下</p>","autoDesc":true}');export{o as comp,u as data};
