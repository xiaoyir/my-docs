import{_ as e,c as i,o as t,d as n}from"./app-J3W_iQKP.js";const s={},a=n('<h1 id="redis的底层数据结构-看起来很复杂-其实一点也不简单" tabindex="-1"><a class="header-anchor" href="#redis的底层数据结构-看起来很复杂-其实一点也不简单"><span>redis的底层数据结构，看起来很复杂，其实一点也不简单</span></a></h1><p>众所周知，redis有String、List、Hash、Set、Sorted Set这五大基本数据类型，不同的数据类型适用不同的场景。不过相信大多数程序员用得最多的还是String，看起来String像是万能的，但你以为String就是简单的字符串吗？其实不然，redis每个数据类型的底层结构都大有文章。</p><p>给大家丢个图就明白了，上面是基本类型，下面是底层结构。像有序集合Sorted Set就用到了压缩列表和跳表。</p><figure><img src="https://javacool.oss-cn-shenzhen.aliyuncs.com/img/xyr/20240525175907.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>现在知道面试官为啥喜欢问redis底层数据结构跳表之类的了吧，原来知识点都在这呢，还不赶紧来复习一下。</p><h3 id="一、redis实体对象" tabindex="-1"><a class="header-anchor" href="#一、redis实体对象"><span>一、redis实体对象</span></a></h3><p>在介绍SDS之前，得先对redis有个基本认知，即redis是一个kv键值数据库，由一张大的哈希表组成，存储的每个字典条目（dictEntry）都是一组kv键值对，dictEntry结构中有三个8字节的指针，分别指向key、value 以及下一个dictEntry，三个指针共 24 字节。key和value都是redis对象（redisObject）。</p><figure><img src="https://javacool.oss-cn-shenzhen.aliyuncs.com/img/xyr/20240525175920.png" alt="img_6" tabindex="0" loading="lazy"><figcaption>img_6</figcaption></figure><p>一个redisObject会包含一个8B的元数据信息及一个8B的指针。具体来讲，8字节的元数据可能包括如下信息：</p><ul><li><p>类型（type）：RedisObject所存储的数据类型，例如字符串、列表、集合等。</p></li><li><p>编码（encoding）：具体数据是如何被编码的，比如int、raw、hastable等。</p></li><li><p>LRU（最少最近使用）：用于实现近似LRU淘汰策略的时间戳或者计数器。</p></li><li><p>引用计数（refcount）：这是一个引用计数器，用于记录有多少个指针正在引用该对象的数据部分，以便正确进行内存管理。</p></li></ul><p>8字节指针指的是一个指向实际数据结构的指针，比如指向SDS的指针或者是其他复杂数据结构的指针。</p><h3 id="二、简单动态字符串" tabindex="-1"><a class="header-anchor" href="#二、简单动态字符串"><span>二、简单动态字符串</span></a></h3><p>String数据类型背后使用的是自定义的动态字符串类型，也就是我们常说的SDS（Simple Dynamic String），它有int、embstr和raw这三种编码模式。</p><ol><li>int编码：当保存的是 Long 类型整数时，RedisObject 中的指针就直接赋值为整数数据了，这样就不用额外的指针再指向整数了，节省了指针的空间开销。</li></ol><figure><img src="https://javacool.oss-cn-shenzhen.aliyuncs.com/img/xyr/20240525175929.png" alt="img_2" tabindex="0" loading="lazy"><figcaption>img_2</figcaption></figure><ol start="2"><li>embstr编码：当保存的是字符串数据，并且字符串小于等于 44 字节时，RedisObject 中的元数据、指针和 SDS 是一块连续的内存区域，这样就可以避免内存碎片。</li></ol><figure><img src="https://javacool.oss-cn-shenzhen.aliyuncs.com/img/xyr/20240525175937.png" alt="img_3" tabindex="0" loading="lazy"><figcaption>img_3</figcaption></figure><ol start="3"><li>raw编码：当字符串大于 44 字节时，SDS 的数据量就开始变多了，Redis 就不再把 SDS 和 RedisObject 布局在一起了，而是会给 SDS 分配独立的空间，并用指针指向 SDS 结构。</li></ol><figure><img src="https://javacool.oss-cn-shenzhen.aliyuncs.com/img/xyr/20240525175944.png" alt="img_4" tabindex="0" loading="lazy"><figcaption>img_4</figcaption></figure><h3 id="二、压缩列表" tabindex="-1"><a class="header-anchor" href="#二、压缩列表"><span>二、压缩列表</span></a></h3><p>当列表、哈希、有序集合存储的数据量较少时，redis就会考虑用ziplist来存储。表结构如下：</p><table><td>zlbytes</td><td>zltail</td><td>zllen</td><td>entry1</td><td>entry2</td><td>...</td><td>entryN</td><td>zlend</td></table><p>压缩列表实际上类似于一个数组，数组中的每一个元素都对应保存一个数据。和数组不同的是，ziplist每个元素长度可以不同，并且在表头有三个字段 zlbytes、zltail 和 zllen，分别表示列表长度、列表尾的偏移量和列表中的 entry 个数；压缩列表在表尾还有一个 zlend，表示列表结束。</p><p>在压缩列表中，如果我们要查找第一个元素和最后一个元素，可以通过表头三个字段的长度直接定位，复杂度是 O(1)。而查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是 O(N) 。</p><h3 id="三、跳表" tabindex="-1"><a class="header-anchor" href="#三、跳表"><span>三、跳表</span></a></h3><p>跳表（skiplist）是在有序链表的基础上，增加了多级索引，通过索引位置的几个跳转，实现数据的快速定位。建立索引可以每隔2个数据建立索引，也可以隔3个或5个。</p><p>像下面这一个有序列表，3，7，11，19，22，26，37。不用跳表需要查找6次，而利用跳表建立的索引，只需要比较4次，时间复杂度可以从原来的O（N）降到O（logN）。</p><figure><img src="https://javacool.oss-cn-shenzhen.aliyuncs.com/img/xyr/20240525175952.png" alt="img_5" tabindex="0" loading="lazy"><figcaption>img_5</figcaption></figure><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><p>好了，SDS、ziplist、skiplist都介绍完了。至于其他的，像hash和set用到的哈希表就是一个hashMap的kv键值对，相当于redis弄了一个嵌套的哈希结构。整数数组和双向链表的操作特征都是顺序读写，也就是通过数组下标或者链表的指针逐个元素访问，操作复杂度基本是O(N)，操作效率比较低。</p><p>显然，整数数组和压缩列表在查找时间复杂度方面并没有很大的优势，那为什么Redis还会把它们作为底层数据结构呢？主要出于以下两点考虑：</p><ol><li><p>内存利用率，数组和压缩列表都是非常紧凑的数据结构，它比链表占用的内存要更少。Redis是内存数据库，大量数据存到内存中，此时需要做尽可能的优化，提高内存的利用率。</p></li><li><p>数组对CPU高速缓存支持更友好，所以Redis在设计时，集合数据元素较少情况下，默认采用内存紧凑排列的方式存储，同时利用CPU高速缓存不会降低访问速度。当数据元素超过设定阈值后，避免查询时间复杂度太高，转为哈希和跳表数据结构存储，保证查询效率。</p></li></ol><p>以上就是全部内容，通过深刻理解Redis的底层数据结构，我们可以更加明确地选择适合自己业务场景的数据类型，从而充分发挥Redis的性能优势。</p>',33),r=[a];function l(o,c){return t(),i("div",null,r)}const d=e(s,[["render",l],["__file","redis的底层数据结构.html.vue"]]),g=JSON.parse('{"path":"/skill/redis/redis%E7%9A%84%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html","title":"redis的底层数据结构，看起来很复杂，其实一点也不简单","lang":"zh-CN","frontmatter":{"description":"redis的底层数据结构，看起来很复杂，其实一点也不简单 众所周知，redis有String、List、Hash、Set、Sorted Set这五大基本数据类型，不同的数据类型适用不同的场景。不过相信大多数程序员用得最多的还是String，看起来String像是万能的，但你以为String就是简单的字符串吗？其实不然，redis每个数据类型的底层结构都...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/my-docs/skill/redis/redis%E7%9A%84%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html"}],["meta",{"property":"og:site_name","content":"Java库"}],["meta",{"property":"og:title","content":"redis的底层数据结构，看起来很复杂，其实一点也不简单"}],["meta",{"property":"og:description","content":"redis的底层数据结构，看起来很复杂，其实一点也不简单 众所周知，redis有String、List、Hash、Set、Sorted Set这五大基本数据类型，不同的数据类型适用不同的场景。不过相信大多数程序员用得最多的还是String，看起来String像是万能的，但你以为String就是简单的字符串吗？其实不然，redis每个数据类型的底层结构都..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://javacool.oss-cn-shenzhen.aliyuncs.com/img/xyr/20240525175907.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-06-02T09:24:29.000Z"}],["meta",{"property":"article:author","content":"程序员小义"}],["meta",{"property":"article:modified_time","content":"2024-06-02T09:24:29.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"redis的底层数据结构，看起来很复杂，其实一点也不简单\\",\\"image\\":[\\"https://javacool.oss-cn-shenzhen.aliyuncs.com/img/xyr/20240525175907.png\\",\\"https://javacool.oss-cn-shenzhen.aliyuncs.com/img/xyr/20240525175920.png\\",\\"https://javacool.oss-cn-shenzhen.aliyuncs.com/img/xyr/20240525175929.png\\",\\"https://javacool.oss-cn-shenzhen.aliyuncs.com/img/xyr/20240525175937.png\\",\\"https://javacool.oss-cn-shenzhen.aliyuncs.com/img/xyr/20240525175944.png\\",\\"https://javacool.oss-cn-shenzhen.aliyuncs.com/img/xyr/20240525175952.png\\"],\\"dateModified\\":\\"2024-06-02T09:24:29.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"程序员小义\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":3,"title":"一、redis实体对象","slug":"一、redis实体对象","link":"#一、redis实体对象","children":[]},{"level":3,"title":"二、简单动态字符串","slug":"二、简单动态字符串","link":"#二、简单动态字符串","children":[]},{"level":3,"title":"二、压缩列表","slug":"二、压缩列表","link":"#二、压缩列表","children":[]},{"level":3,"title":"三、跳表","slug":"三、跳表","link":"#三、跳表","children":[]},{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":1717320269000,"updatedTime":1717320269000,"contributors":[{"name":"whuhbz","email":"463436681@qq.com","commits":1}]},"readingTime":{"minutes":5.16,"words":1549},"filePathRelative":"skill/redis/redis的底层数据结构.md","localizedDate":"2024年6月2日","excerpt":"\\n<p>众所周知，redis有String、List、Hash、Set、Sorted Set这五大基本数据类型，不同的数据类型适用不同的场景。不过相信大多数程序员用得最多的还是String，看起来String像是万能的，但你以为String就是简单的字符串吗？其实不然，redis每个数据类型的底层结构都大有文章。</p>\\n<p>给大家丢个图就明白了，上面是基本类型，下面是底层结构。像有序集合Sorted Set就用到了压缩列表和跳表。</p>\\n<figure><img src=\\"https://javacool.oss-cn-shenzhen.aliyuncs.com/img/xyr/20240525175907.png\\" alt=\\"img\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption>img</figcaption></figure>","autoDesc":true}');export{d as comp,g as data};
