import{_ as s,c as n,o as a,d as e}from"./app-9aLaKr4C.js";const i={},l=e(`<h1 id="java8编程小技巧-提高代码效率100-超级实用" tabindex="-1"><a class="header-anchor" href="#java8编程小技巧-提高代码效率100-超级实用"><span>Java8编程小技巧，提高代码效率100%！超级实用！</span></a></h1><p>大家好，我是小义，今天分享几个Java8编程小技巧，提高代码逼格，写出优雅代码，让同事看了也直呼内行。</p><h3 id="一、树形结构" tabindex="-1"><a class="header-anchor" href="#一、树形结构"><span>一、树形结构</span></a></h3><p>像页面菜单、淘宝分类、行政区划等都是树形结构，后端往往是用一张包含父子节点的数据库表来存储，需要在代码层面自己组装成结构树，可以用stream和递归快速实现。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>public class OrderTest {</span></span>
<span class="line"><span>    //节点结构</span></span>
<span class="line"><span>    @Data</span></span>
<span class="line"><span>    @Accessors(chain = true)</span></span>
<span class="line"><span>    public class NodeDTO {</span></span>
<span class="line"><span>        private String id;</span></span>
<span class="line"><span>        private String name;</span></span>
<span class="line"><span>        private String parentId;</span></span>
<span class="line"><span>        private List&lt;NodeDTO&gt; children;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Test</span></span>
<span class="line"><span>    public void children() {</span></span>
<span class="line"><span>        //模拟数据</span></span>
<span class="line"><span>        List&lt;NodeDTO&gt; list = new ArrayList&lt;NodeDTO&gt;(){{
            add(new NodeDTO().setId(&quot;3&quot;).setParentId(&quot;0&quot;).setName(&quot;广西&quot;));
            add(new NodeDTO().setId(&quot;36&quot;).setParentId(&quot;3&quot;).setName(&quot;桂林市&quot;));
            add(new NodeDTO().setId(&quot;369&quot;).setParentId(&quot;36&quot;).setName(&quot;阳朔县&quot;));
            add(new NodeDTO().setId(&quot;2&quot;).setParentId(&quot;0&quot;).setName(&quot;广东&quot;));
            add(new NodeDTO().setId(&quot;21&quot;).setParentId(&quot;2&quot;).setName(&quot;深圳&quot;));
            add(new NodeDTO().setId(&quot;22&quot;).setParentId(&quot;2&quot;).setName(&quot;广州&quot;));
            add(new NodeDTO().setId(&quot;211&quot;).setParentId(&quot;21&quot;).setName(&quot;南山区&quot;));
            add(new NodeDTO().setId(&quot;985&quot;).setParentId(&quot;21&quot;).setName(&quot;福田区&quot;));
            add(new NodeDTO().setId(&quot;1&quot;).setParentId(&quot;0&quot;).setName(&quot;北京市&quot;));
            add(new NodeDTO().setId(&quot;11&quot;).setParentId(&quot;1&quot;).setName(&quot;朝阳区&quot;));
        }};</span></span>
<span class="line"><span>        //获取行政区划结构树</span></span>
<span class="line"><span>        List&lt;NodeDTO&gt; treeNode = getTreeNode(new NodeDTO().setId(&quot;0&quot;), list);</span></span>
<span class="line"><span>        System.out.println(treeNode);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * 节点递归调用</span></span>
<span class="line"><span>     * @param root</span></span>
<span class="line"><span>     * @param all</span></span>
<span class="line"><span>     * @return</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    private List&lt;NodeDTO&gt; getTreeNode(NodeDTO root, List&lt;NodeDTO&gt; all) {</span></span>
<span class="line"><span>        List&lt;NodeDTO&gt; collect = all.stream().filter(node -&gt; Objects.equals(root.getId(), node.getParentId()))</span></span>
<span class="line"><span>                .map(levelNode -&gt; levelNode.setChildren(getTreeNode(levelNode, all))).collect(Collectors.toList());</span></span>
<span class="line"><span>        return collect;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="二、optional取值" tabindex="-1"><a class="header-anchor" href="#二、optional取值"><span>二、Optional取值</span></a></h3><p>当对对象的属性取值时，一不小心就可能报空指针异常，特别是属性嵌套的时候。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>@Data</span></span>
<span class="line"><span>@Accessors(chain = true)</span></span>
<span class="line"><span>public class UserDTO {</span></span>
<span class="line"><span>    private String personId;</span></span>
<span class="line"><span>    private String name;</span></span>
<span class="line"><span>    private String age;</span></span>
<span class="line"><span>    private CarDTO car;</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>    @Data</span></span>
<span class="line"><span>    public static class CarDTO {</span></span>
<span class="line"><span>        private String name;</span></span>
<span class="line"><span>        private SignPaper signPaper;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>    @Data</span></span>
<span class="line"><span>    public static class SignPaper {</span></span>
<span class="line"><span>        private String signName;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>针对UserDTO类，要想取到SignPaper的name值，就得层层判空，像下面这样。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>  public String testSignName(UserDTO user) {</span></span>
<span class="line"><span>      if (null == user) {</span></span>
<span class="line"><span>          return &quot;&quot;;</span></span>
<span class="line"><span>      }</span></span>
<span class="line"><span>      if (null == user.getCar()) {</span></span>
<span class="line"><span>          return &quot;&quot;;</span></span>
<span class="line"><span>      }</span></span>
<span class="line"><span>      if (null == user.getCar().getSignPaper()) {</span></span>
<span class="line"><span>          return &quot;&quot;;</span></span>
<span class="line"><span>      }</span></span>
<span class="line"><span>      return user.getCar().getSignPaper().getSignName();</span></span>
<span class="line"><span>  }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但利用Optional，只用一行代码就可以解决。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>String signName = Optional.ofNullable(user).map(userDTO -&gt; userDTO.getCar()).map(carDTO -&gt; carDTO.getSignPaper()).map(SignPaper::getSignName).orElse(&quot;&quot;);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="列表运算" tabindex="-1"><a class="header-anchor" href="#列表运算"><span>列表运算</span></a></h3><ol><li>排序。列表排序在业务场景中经常会使用到，可以通过List本身的sort方法来实现。</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>List&lt;UserDTO&gt; list = Lists.newArrayList();</span></span>
<span class="line"><span>//先按年龄字段从小到大排序，并把空值的放后面；接着按姓名排序</span></span>
<span class="line"><span>list.sort(Comparator.comparing(UserDTO::getAge, Comparator.nullsLast(Comparator.naturalOrder())).thenComparing(UserDTO::getName));</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>属性去重。列表往往还需要去重，像只针对对象的某个字段去重的特殊操作，需要借助TreeSet的唯一性来实现。</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>List&lt;UserDTO&gt; list = Lists.newArrayList();</span></span>
<span class="line"><span>//list.add(...)</span></span>
<span class="line"><span>//对象属性去重</span></span>
<span class="line"><span>List&lt;UserDTO&gt; distinctList = list.stream().collect(Collectors.collectingAndThen(Collectors.toCollection(() -&gt; new TreeSet&lt;&gt;(Comparator.comparing(UserDTO::getPersonId))), ArrayList::new));</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>BigDecimal求和。金额计算统一用BigDecimal来计算，可以避免精度缺失。求和代码示例如下：</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>List&lt;CarDTO&gt; carDTOList = Lists.newArrayList();</span></span>
<span class="line"><span>        BigDecimal sum = carDTOList.stream().map(car -&gt; Optional.ofNullable(car.getPrice()).orElse(BigDecimal.ZERO)).reduce(BigDecimal.ZERO, BigDecimal::add);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ol start="4"><li>分组。将列表分组拼接需要的字符串或者是分组后再对分组后的子列表做聚合。</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>//按年龄分组，然后拼接姓名</span></span>
<span class="line"><span>Map&lt;String, String&gt; ageMap = list.stream().collect(Collectors.groupingBy(UserDTO::getAge,</span></span>
<span class="line"><span>                Collectors.mapping(UserDTO::getName, Collectors.joining(&quot;,&quot;))));</span></span>
<span class="line"><span></span></span>
<span class="line"><span>//先按年龄分组，再将各小组数据组装成统计实体，最后返回一个列表</span></span>
<span class="line"><span>List&lt;OverviewDTO&gt; overviewList = list.stream().collect(Collectors.groupingBy(UserDTO::getAge, Collectors.toList())).entrySet().stream().map(entry -&gt; {</span></span>
<span class="line"><span>    OverviewDTO overview = new OverviewDTO();</span></span>
<span class="line"><span>    overview.setCarName(entry.getValue().stream().map(userDTO -&gt; Optional.ofNullable(userDTO.getCar()).map(CarDTO::getName).orElse(&quot;&quot;))</span></span>
<span class="line"><span>            .collect(Collectors.joining(&quot;,&quot;)));</span></span>
<span class="line"><span>    overview.setAge(entry.getKey());</span></span>
<span class="line"><span>    return overview;</span></span>
<span class="line"><span>}).collect(Collectors.toList());</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="5"><li>降维。列表里面嵌套列表的场景也很常见，像下面的PayDTO结构。</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>@Data</span></span>
<span class="line"><span>public class PayDTO {</span></span>
<span class="line"><span>    private BigDecimal sumPay;</span></span>
<span class="line"><span>    private String orderNo;</span></span>
<span class="line"><span>    private List&lt;BatchPayDTO&gt; batchPayList;</span></span>
<span class="line"><span>    @Data</span></span>
<span class="line"><span>    public static class BatchPayDTO {</span></span>
<span class="line"><span>        private String batchNo;</span></span>
<span class="line"><span>        List&lt;BatchPlanDTO&gt; batchPlanList;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    @Data</span></span>
<span class="line"><span>    public static class BatchPlanDTO {</span></span>
<span class="line"><span>        private String planNo;</span></span>
<span class="line"><span>        List&lt;GoodsInfoDTO&gt; goodsPayList;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    @Data</span></span>
<span class="line"><span>    public static class GoodsInfoDTO {</span></span>
<span class="line"><span>        private String goodsNo;</span></span>
<span class="line"><span>        private String Code;</span></span>
<span class="line"><span>        private String Name;</span></span>
<span class="line"><span>        private BigDecimal payAmount;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果要获取PayDTO最里层的GoodsInfoDTO列表项，传统方式可能像下面这样层层遍历。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>ArrayList&lt;PayDTO&gt; payList = Lists.newArrayList();</span></span>
<span class="line"><span>//payList.add(...)</span></span>
<span class="line"><span>List&lt;PayDTO.GoodsInfoDTO&gt; goodsList = Lists.newArrayList();</span></span>
<span class="line"><span>for (PayDTO payDTO : payList) {</span></span>
<span class="line"><span>    if (CollUtil.isNotEmpty(payDTO.getBatchPayList())) {</span></span>
<span class="line"><span>        for (PayDTO.BatchPayDTO batchPayDTO : payDTO.getBatchPayList()) {</span></span>
<span class="line"><span>            if (CollUtil.isNotEmpty(batchPayDTO.getBatchPlanList())) {</span></span>
<span class="line"><span>                for (PayDTO.BatchPlanDTO batchPlanDTO : batchPayDTO.getBatchPlanList()) {</span></span>
<span class="line"><span>                    if (CollUtil.isNotEmpty(batchPlanDTO.getGoodsPayList())) {</span></span>
<span class="line"><span>                        goodsList.addAll(batchPlanDTO.getGoodsPayList());</span></span>
<span class="line"><span>                    }</span></span>
<span class="line"><span>                }</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>看起来不太优雅，判断繁琐，括号又多，换成stream流式运算就可以完美解决。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>ArrayList&lt;PayDTO&gt; payList = Lists.newArrayList();</span></span>
<span class="line"><span>//payList.add(...)</span></span>
<span class="line"><span>List&lt;PayDTO.GoodsInfoDTO&gt; goodsInfoList = payList.stream()</span></span>
<span class="line"><span>        .filter(i -&gt; CollUtil.isNotEmpty(i.getBatchPayList())).flatMap(i -&gt; i.getBatchPayList().stream())</span></span>
<span class="line"><span>        .filter(j -&gt; CollUtil.isNotEmpty(j.getBatchPlanList())).flatMap(j -&gt; j.getBatchPlanList().stream())</span></span>
<span class="line"><span>        .filter(k -&gt; CollUtil.isNotEmpty(k.getGoodsPayList())).flatMap(k -&gt; k.getGoodsPayList().stream())</span></span>
<span class="line"><span>        .collect(Collectors.toList());</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,27),t=[l];function p(d,r){return a(),n("div",null,t)}const v=s(i,[["render",p],["__file","Java8编程小技巧.html.vue"]]),o=JSON.parse('{"path":"/skill/java/Java8%E7%BC%96%E7%A8%8B%E5%B0%8F%E6%8A%80%E5%B7%A7.html","title":"Java8编程小技巧","lang":"zh-CN","frontmatter":{"title":"Java8编程小技巧","icon":"laptop-code","category":["java"],"description":"Java8编程小技巧，提高代码效率100%！超级实用！ 大家好，我是小义，今天分享几个Java8编程小技巧，提高代码逼格，写出优雅代码，让同事看了也直呼内行。 一、树形结构 像页面菜单、淘宝分类、行政区划等都是树形结构，后端往往是用一张包含父子节点的数据库表来存储，需要在代码层面自己组装成结构树，可以用stream和递归快速实现。 二、Optional...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/my-docs/skill/java/Java8%E7%BC%96%E7%A8%8B%E5%B0%8F%E6%8A%80%E5%B7%A7.html"}],["meta",{"property":"og:site_name","content":"Java库"}],["meta",{"property":"og:title","content":"Java8编程小技巧"}],["meta",{"property":"og:description","content":"Java8编程小技巧，提高代码效率100%！超级实用！ 大家好，我是小义，今天分享几个Java8编程小技巧，提高代码逼格，写出优雅代码，让同事看了也直呼内行。 一、树形结构 像页面菜单、淘宝分类、行政区划等都是树形结构，后端往往是用一张包含父子节点的数据库表来存储，需要在代码层面自己组装成结构树，可以用stream和递归快速实现。 二、Optional..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-06-02T15:08:55.000Z"}],["meta",{"property":"article:author","content":"程序员小义"}],["meta",{"property":"article:modified_time","content":"2024-06-02T15:08:55.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java8编程小技巧\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-06-02T15:08:55.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"程序员小义\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":3,"title":"一、树形结构","slug":"一、树形结构","link":"#一、树形结构","children":[]},{"level":3,"title":"二、Optional取值","slug":"二、optional取值","link":"#二、optional取值","children":[]},{"level":3,"title":"列表运算","slug":"列表运算","link":"#列表运算","children":[]}],"git":{"createdTime":1717320269000,"updatedTime":1717340935000,"contributors":[{"name":"whuhbz","email":"463436681@qq.com","commits":3}]},"readingTime":{"minutes":3.43,"words":1029},"filePathRelative":"skill/java/Java8编程小技巧.md","localizedDate":"2024年6月2日","excerpt":"\\n<p>大家好，我是小义，今天分享几个Java8编程小技巧，提高代码逼格，写出优雅代码，让同事看了也直呼内行。</p>\\n<h3>一、树形结构</h3>\\n<p>像页面菜单、淘宝分类、行政区划等都是树形结构，后端往往是用一张包含父子节点的数据库表来存储，需要在代码层面自己组装成结构树，可以用stream和递归快速实现。</p>\\n<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" data-title=\\"\\" style=\\"--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes github-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>public class OrderTest {</span></span>\\n<span class=\\"line\\"><span>    //节点结构</span></span>\\n<span class=\\"line\\"><span>    @Data</span></span>\\n<span class=\\"line\\"><span>    @Accessors(chain = true)</span></span>\\n<span class=\\"line\\"><span>    public class NodeDTO {</span></span>\\n<span class=\\"line\\"><span>        private String id;</span></span>\\n<span class=\\"line\\"><span>        private String name;</span></span>\\n<span class=\\"line\\"><span>        private String parentId;</span></span>\\n<span class=\\"line\\"><span>        private List&lt;NodeDTO&gt; children;</span></span>\\n<span class=\\"line\\"><span>    }</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>    @Test</span></span>\\n<span class=\\"line\\"><span>    public void children() {</span></span>\\n<span class=\\"line\\"><span>        //模拟数据</span></span>\\n<span class=\\"line\\"><span>        List&lt;NodeDTO&gt; list = new ArrayList&lt;NodeDTO&gt;(){{\\n            add(new NodeDTO().setId(\\"3\\").setParentId(\\"0\\").setName(\\"广西\\"));\\n            add(new NodeDTO().setId(\\"36\\").setParentId(\\"3\\").setName(\\"桂林市\\"));\\n            add(new NodeDTO().setId(\\"369\\").setParentId(\\"36\\").setName(\\"阳朔县\\"));\\n            add(new NodeDTO().setId(\\"2\\").setParentId(\\"0\\").setName(\\"广东\\"));\\n            add(new NodeDTO().setId(\\"21\\").setParentId(\\"2\\").setName(\\"深圳\\"));\\n            add(new NodeDTO().setId(\\"22\\").setParentId(\\"2\\").setName(\\"广州\\"));\\n            add(new NodeDTO().setId(\\"211\\").setParentId(\\"21\\").setName(\\"南山区\\"));\\n            add(new NodeDTO().setId(\\"985\\").setParentId(\\"21\\").setName(\\"福田区\\"));\\n            add(new NodeDTO().setId(\\"1\\").setParentId(\\"0\\").setName(\\"北京市\\"));\\n            add(new NodeDTO().setId(\\"11\\").setParentId(\\"1\\").setName(\\"朝阳区\\"));\\n        }};</span></span>\\n<span class=\\"line\\"><span>        //获取行政区划结构树</span></span>\\n<span class=\\"line\\"><span>        List&lt;NodeDTO&gt; treeNode = getTreeNode(new NodeDTO().setId(\\"0\\"), list);</span></span>\\n<span class=\\"line\\"><span>        System.out.println(treeNode);</span></span>\\n<span class=\\"line\\"><span>    }</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>    /**</span></span>\\n<span class=\\"line\\"><span>     * 节点递归调用</span></span>\\n<span class=\\"line\\"><span>     * @param root</span></span>\\n<span class=\\"line\\"><span>     * @param all</span></span>\\n<span class=\\"line\\"><span>     * @return</span></span>\\n<span class=\\"line\\"><span>     */</span></span>\\n<span class=\\"line\\"><span>    private List&lt;NodeDTO&gt; getTreeNode(NodeDTO root, List&lt;NodeDTO&gt; all) {</span></span>\\n<span class=\\"line\\"><span>        List&lt;NodeDTO&gt; collect = all.stream().filter(node -&gt; Objects.equals(root.getId(), node.getParentId()))</span></span>\\n<span class=\\"line\\"><span>                .map(levelNode -&gt; levelNode.setChildren(getTreeNode(levelNode, all))).collect(Collectors.toList());</span></span>\\n<span class=\\"line\\"><span>        return collect;</span></span>\\n<span class=\\"line\\"><span>    }</span></span>\\n<span class=\\"line\\"><span>}</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}');export{v as comp,o as data};
